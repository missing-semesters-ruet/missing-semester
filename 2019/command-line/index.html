<!DOCTYPE html>
<html lang="en">

  <head>
  <meta charset="utf-8" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png" />
  <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png" />
  <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png" />

  <meta name="twitter:card" content="summary_large_image" />
  <meta name="og:url" content="https://missing-semesters-ruet.github.io//2019/command-line/" />
  <meta property="og:site_name" content="The Missing Semesters of Your CS" />

   
  <meta name="twitter:title" content="Command-line environment" />
  <meta property="og:title" content="Command-line environment" />

  

  <title>
      Command-line environment &middot; The Missing Semesters of Your CS  
  </title>

  <link rel="stylesheet" href="/missing-semester/static/css/main.css" />
  <link rel="stylesheet" href="/missing-semester/static/css/syntax.css" />
  <link rel="stylesheet" href="/missing-semester/static/css/note.css" />
  <link
    href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:200,300,400,600,700,900,200italic,300italic,400italic,600italic,700italic,900italic&subset=latin,latin-ext"
    rel="stylesheet"
    type="text/css"
  />
  <link
    href="https://fonts.googleapis.com/css?family=Source+Code+Pro:200,300,400,500,600,700,900&subset=latin,latin-ext"
    rel="stylesheet"
    type="text/css"
  />

  <script
    async
    src="https://www.googletagmanager.com/gtag/js?id=G-P7WVHD84D1"
  ></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag() {
      dataLayer.push(arguments);
    }
    gtag("js", new Date());

    gtag("config", "G-P7WVHD84D1");
  </script>
</head>


  <body>

    <div id="nav-bg">
  <nav id="top-nav">
    <a href="/missing-semester/" id="logo">./missing-semester</a>
    <input type="checkbox" id="menu-icon" />
    <label class="menu-label" for="menu-icon"></label>
    <div class="trigger">
      <div class="trigger-child">
        <span class="nav-link"
          ><a href="/missing-semester/2025/">lectures</a></span
        >
        <span class="nav-link">
          <a href="/missing-semester/statement_of_intent"
            >statement of intent</a
          >
        </span>
        <span class="nav-link"
          ><a href="/missing-semester/about/">about</a></span
        >
      </div>
    </div>
  </nav>
</div>


    <div id="content">
    <h1 class="title">Command-line environment</h1>


  <div class="youtube-wrapper" style="padding-bottom: 62.5%;">
    <iframe src="https://www.youtube.com/embed/i0rf1gpKL1E" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
  </div>


<h2 id="aliases--functions">Aliases &amp; Functions</h2>

<p>As you can imagine it can become tiresome typing long commands that involve many flags or verbose options. Nevertheless, most shells support <strong>aliasing</strong>. For instance, an alias in bash has the following structure (note there is no space around the <code class="language-plaintext highlighter-rouge">=</code> sign):</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">alias </span><span class="nv">alias_name</span><span class="o">=</span><span class="s2">"command_to_alias"</span>
</code></pre></div></div>

<!-- We can alias common flags for our commands like `alias ll=ls -ltAh`. Alias can be composed  -->

<p>Alias have many convenient features</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># Alias can summarize good default flags</span>
<span class="nb">alias </span><span class="nv">ll</span><span class="o">=</span><span class="s2">"ls -lh"</span>

<span class="c"># Save a lot of typing for common commands</span>
<span class="nb">alias </span><span class="nv">gc</span><span class="o">=</span><span class="s2">"git commit"</span>

<span class="c"># Alias can overwrite existing commands</span>
<span class="nb">alias mv</span><span class="o">=</span><span class="s2">"mv -i"</span>
<span class="nb">alias mkdir</span><span class="o">=</span><span class="s2">"mkdir -p"</span>

<span class="c"># Alias can be composed</span>
<span class="nb">alias </span><span class="nv">la</span><span class="o">=</span><span class="s2">"ls -A"</span>
<span class="nb">alias </span><span class="nv">lla</span><span class="o">=</span><span class="s2">"la -l"</span>

<span class="c"># To ignore an alias run it prepended with \</span>
<span class="se">\l</span>s
<span class="c"># Or can be disabled using unalias</span>
<span class="nb">unalias </span>la

</code></pre></div></div>
<!--
To get rid of an alias you can run `unalias alias_name` or to ignore alias when running a command you can prepend the command with a backward slash `\alias_name`. This is convenient when an alias is overwriting an existing name. -->

<p>However in many scenarios aliases can be limiting, specially when you are trying to write chain commands together that take the same arguments. An alternative exists which is <strong>functions</strong> which are a midpoint between aliases and custom shell scripts.</p>

<p>Here is an example function that makes a directory and move into it.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mcd <span class="o">()</span> <span class="o">{</span>
    <span class="nb">mkdir</span> <span class="nt">-p</span> <span class="nv">$1</span>
    <span class="nb">cd</span> <span class="nv">$1</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Alias and functions will not persist shell sessions by default. To make an alias persistent you need to include it a one the shell startup script files like <code class="language-plaintext highlighter-rouge">.bashrc</code> or <code class="language-plaintext highlighter-rouge">.zshrc</code>. My suggestion is to write them separately in a <code class="language-plaintext highlighter-rouge">.alias</code> and <code class="language-plaintext highlighter-rouge">source</code> that file from your different shell config files.</p>

<!-- Lastly, if you decide to alias any of these tools with the "improved" version, e.g. `alias bat=cat` it is useful to know that you can tell bash to ignore aliases by doing `\cat` and ignore both aliases and functions by doing `command cat` -->

<h2 id="shells--frameworks">Shells &amp; Frameworks</h2>

<p>During shell and scripting we covered the <code class="language-plaintext highlighter-rouge">bash</code> shell since it is by far the most ubiquitous shell and most systems have it as the default option. Nevertheless, it is not the only option.</p>

<p>For example the <code class="language-plaintext highlighter-rouge">zsh</code> shell is a superset of <code class="language-plaintext highlighter-rouge">bash</code> and provides many convenient features out of the box such as:</p>

<ul>
  <li>Smarter globbing, <code class="language-plaintext highlighter-rouge">**</code></li>
  <li>Inline globbing/wildcard expansion</li>
  <li>Spelling correction</li>
  <li>Better tab completion/selection</li>
  <li>Path expansion (<code class="language-plaintext highlighter-rouge">cd /u/lo/b</code> will expand as <code class="language-plaintext highlighter-rouge">/usr/local/bin</code>)</li>
</ul>

<p>Moreover many shells can be improved with <strong>frameworks</strong>, some popular general frameworks like <a href="https://github.com/sorin-ionescu/prezto">prezto</a> or <a href="https://github.com/robbyrussell/oh-my-zsh">oh-my-zsh</a>, and smaller ones that focus on specific features like for example <a href="https://github.com/zsh-users/zsh-syntax-highlighting">zsh-syntax-highlighting</a> or <a href="https://github.com/zsh-users/zsh-history-substring-search">zsh-history-substring-search</a>. Other shells like <a href="https://fishshell.com/">fish</a> include a lot of these user-friendly features by default. Some of these features include:</p>

<ul>
  <li>Right prompt</li>
  <li>Command syntax highlighting</li>
  <li>History substring search</li>
  <li>manpage based flag completions</li>
  <li>Smarter autocompletion</li>
  <li>Prompt themes</li>
</ul>

<p>One thing to note when using these frameworks is that if the code they run is not properly optimized or it is too much code, your shell can start slowing down. You can always profile it and disable the features that you do not use often or value over speed.</p>

<h2 id="terminal-emulators--multiplexers">Terminal Emulators &amp; Multiplexers</h2>

<p>Along with customizing your shell it is worth spending some time figuring out your choice of <strong>terminal emulator</strong> and its settings. There are many many terminal emulators out there (here is a <a href="https://anarc.at/blog/2018-04-12-terminal-emulators-1/">comparison</a>).</p>

<p>Since you might be spending hundreds to thousands of hours in your terminal it pays off to look into its settings. Some of the aspects that you may want to modify in your terminal include:</p>

<ul>
  <li>Font choice</li>
  <li>Color Scheme</li>
  <li>Keyboard shortcuts</li>
  <li>Tab/Pane support</li>
  <li>Scrollback configuration</li>
  <li>Performance (some newer terminals like <a href="https://github.com/jwilm/alacritty">Alacritty</a> offer GPU acceleration)</li>
</ul>

<p>It is also worth mentioning <strong>terminal multiplexers</strong> like <a href="https://github.com/tmux/tmux">tmux</a>. <code class="language-plaintext highlighter-rouge">tmux</code> allows you to pane and tab multiple shell sessions. It also supports attaching and detaching which is a very common use-case when you are working on a remote server and want to keep you shell running without having to worry about disowning you current processes (by default when you log out your processes are terminated).  This way, with <code class="language-plaintext highlighter-rouge">tmux</code> you can jump into and out of complex terminal layouts. Similar to terminal emulators <code class="language-plaintext highlighter-rouge">tmux</code> supports heavy customization by editing the <code class="language-plaintext highlighter-rouge">~/.tmux.conf</code> file.</p>

<h2 id="command-line-utilities">Command-line utilities</h2>

<p>The command line utilities that most UNIX based operating systems have by default are more than enough to do 99% of the stuff you usually need to do.</p>

<p>In the next few subsections I will cover alternative tools for extremely common shell operations which are more convenient to use. Some of these tools add new improved functionality to the command whereas others just focus on providing a simpler, more intuitive interface with better defaults.</p>

<h3 id="fasd-vs-cd"><code class="language-plaintext highlighter-rouge">fasd</code> vs <code class="language-plaintext highlighter-rouge">cd</code></h3>

<p>Even with improved path expansion and tab autocomplete, changing directories can become quite repetitive. <a href="https://github.com/clvv/fasd">Fasd</a> (or <a href="https://github.com/wting/autojump">autojump</a>) solves this issue by keeping track of recent and frequent folders you have been to and performing fuzzy matching.</p>

<p>Thus if I have visited the path <code class="language-plaintext highlighter-rouge">/home/user/awesome_project/code</code> running <code class="language-plaintext highlighter-rouge">z code</code> will <code class="language-plaintext highlighter-rouge">cd</code> to it. If I have multiple folders called code I can disambiguate by running <code class="language-plaintext highlighter-rouge">z awe code</code> which will be closer match. Unlike autojump,  fasd also provides commands that instead of performing <code class="language-plaintext highlighter-rouge">cd</code> just expand frequent and /or recent files,folders or both.</p>

<h3 id="bat-vs-cat"><code class="language-plaintext highlighter-rouge">bat</code> vs <code class="language-plaintext highlighter-rouge">cat</code></h3>

<p>Even though <code class="language-plaintext highlighter-rouge">cat</code> does it job perfectly, <a href="https://github.com/sharkdp/bat">bat</a> improves it by providing syntax highlighting, paging, line numbers and git integration.</p>

<h3 id="exaranger-vs-ls"><code class="language-plaintext highlighter-rouge">exa</code>/<code class="language-plaintext highlighter-rouge">ranger</code> vs <code class="language-plaintext highlighter-rouge">ls</code></h3>

<p><code class="language-plaintext highlighter-rouge">ls</code> is a great command but some of the defaults can be annoying such as displaying the size in raw bytes. <a href="https://github.com/ogham/exa">exa</a> provides better defaults</p>

<p>If you are in need of navigating many folders and/or previewing many files, <a href="https://github.com/ranger/ranger">ranger</a> can be much more efficient than <code class="language-plaintext highlighter-rouge">cd</code> and <code class="language-plaintext highlighter-rouge">cat</code> due to its wonderful interface. It is quite customizable and with a correct setup you can even <a href="https://github.com/ranger/ranger/wiki/Image-Previews">preview images</a> in your terminal</p>

<h3 id="fd-vs-find"><code class="language-plaintext highlighter-rouge">fd</code> vs <code class="language-plaintext highlighter-rouge">find</code></h3>

<p><a href="https://github.com/sharkdp/fd">fd</a> is a simple, fast and user-friendly alternative to <code class="language-plaintext highlighter-rouge">find</code>. <code class="language-plaintext highlighter-rouge">find</code> defaults like having to use the <code class="language-plaintext highlighter-rouge">--name</code> flag (which is what you want to do 99% of the time) make it easier to use in an every day basis. It is also <code class="language-plaintext highlighter-rouge">git</code> aware and will skip files in your <code class="language-plaintext highlighter-rouge">.gitignore</code> and <code class="language-plaintext highlighter-rouge">.git</code> folder by default. It also has nice color coding by default.</p>

<h3 id="rgfzf-vs-grep"><code class="language-plaintext highlighter-rouge">rg/fzf</code> vs <code class="language-plaintext highlighter-rouge">grep</code></h3>

<p><code class="language-plaintext highlighter-rouge">grep</code> is a great tool but if you want to grep through many files at once, there are better tools for that purpose. <a href="https://github.com/beyondgrep/ack3">ack</a>, <a href="https://github.com/ggreer/the_silver_searcher">ag</a> &amp; <a href="https://github.com/BurntSushi/ripgrep">rg</a> recursively search your current directory for a regex pattern while respecting your gitignore rules. They all work pretty similar but I favor <code class="language-plaintext highlighter-rouge">rg</code> due to how fast it can search my entire home directory.</p>

<p>Similarly, it can be easy to find yourself doing <code class="language-plaintext highlighter-rouge">CMD | grep PATTERN</code> over an over again. <a href="https://github.com/junegunn/fzf">fzf</a> is a command line fuzzy finder that enables you to interactively filter the output of pretty much any command.</p>

<h3 id="rsync-vs-cpscp"><code class="language-plaintext highlighter-rouge">rsync</code> vs <code class="language-plaintext highlighter-rouge">cp/scp</code></h3>

<p>Whereas <code class="language-plaintext highlighter-rouge">mv</code> and <code class="language-plaintext highlighter-rouge">scp</code> are perfect for most scenarios, when copying/moving around large amounts of files, large files or when some of the data is already on the destination <code class="language-plaintext highlighter-rouge">rsync</code> is a huge improvement. <code class="language-plaintext highlighter-rouge">rsync</code> will skip files that have already been transferred and with the <code class="language-plaintext highlighter-rouge">--partial</code> flag it can resume from a previously interrupted copy.</p>

<h3 id="trash-vs-rm"><code class="language-plaintext highlighter-rouge">trash</code> vs <code class="language-plaintext highlighter-rouge">rm</code></h3>

<p><code class="language-plaintext highlighter-rouge">rm</code> is a dangerous command in the sense that once you delete a file there is no turning back. However, modern OS do not behave like that when you delete something in the file explorer, they just move it to the Trash folder which is cleared periodically.</p>

<p>Since how the trash is managed varies from OS to OS there is not a single CLI utility. In macOS there is <a href="https://hasseg.org/trash/">trash</a> and in linux there is <a href="https://github.com/andreafrancia/trash-cli/">trash-cli</a> among others.</p>

<h3 id="mosh-vs-ssh"><code class="language-plaintext highlighter-rouge">mosh</code> vs <code class="language-plaintext highlighter-rouge">ssh</code></h3>

<p><code class="language-plaintext highlighter-rouge">ssh </code> is a very handy tool but if you have a slow connection, the lag can become annoying and if the connection interrupts you have to reconnect. <a href="https://mosh.org/">mosh</a> is a handy tool that works allows roaming, supports intermittent connectivity, and provides intelligent local echo.</p>

<h3 id="tldr-vs-man"><code class="language-plaintext highlighter-rouge">tldr</code> vs <code class="language-plaintext highlighter-rouge">man</code></h3>

<p>You can figure out what a commands does and what options it has using <code class="language-plaintext highlighter-rouge">man</code> and the <code class="language-plaintext highlighter-rouge">-h</code>/’–help’ flag most of the time. However, in some cases it can be a bit daunting navigating these if they are detailed</p>

<p>The <a href="https://github.com/tldr-pages/tldr">tldr</a> command is a community driven documentation system that’s available from the command line and gives a few simple illustrative examples of what the command does and the most common argument options.</p>

<h3 id="aunpack-vs-tarunzipunrar"><code class="language-plaintext highlighter-rouge">aunpack</code> vs <code class="language-plaintext highlighter-rouge">tar/unzip/unrar</code></h3>

<p>As <a href="https://xkcd.com/1168/">this xkcd</a> references, it can be quite tricky to remember the options for <code class="language-plaintext highlighter-rouge">tar</code> and sometimes you need a different tool altogether such as <code class="language-plaintext highlighter-rouge">unrar</code> for .rar files.
The <a href="https://www.nongnu.org/atool/">atool</a> package provides the <code class="language-plaintext highlighter-rouge">aunpack</code> command which will figure out the correct options and always put the extracted archives in a new folder.</p>

<h2 id="exercises">Exercises</h2>

<ol>
  <li>Run <code class="language-plaintext highlighter-rouge">cat .bash_history | sort | uniq -c | sort -rn | head -n 10</code> (or <code class="language-plaintext highlighter-rouge">cat .zhistory | sort | uniq -c | sort -rn | head -n 10</code> for zsh)  to get top 10 most used commands and consider writing shorter aliases for them</li>
  <li>Choose a terminal emulator and figure out how to change the following properties:
    <ul>
      <li>Font choice</li>
      <li>Color scheme. How many colors does a standard scheme have? why?</li>
      <li>Scrollback history size</li>
    </ul>
  </li>
  <li>Install <code class="language-plaintext highlighter-rouge">fasd</code> or some similar software and write a bash/zsh function called <code class="language-plaintext highlighter-rouge">v</code> that performs fuzzy matching on the passed arguments and opens up the top result in your editor of choice. Then, modify it so that if there are multiple matches you can select them with <code class="language-plaintext highlighter-rouge">fzf</code>.</li>
  <li>Since <code class="language-plaintext highlighter-rouge">fzf</code> is quite convenient for performing fuzzy searches and the shell history is quite prone to those kind of searches, investigate how to bind <code class="language-plaintext highlighter-rouge">fzf</code> to <code class="language-plaintext highlighter-rouge">^R</code>. You can find some info <a href="https://github.com/junegunn/fzf/wiki/Configuring-shell-key-bindings">here</a></li>
  <li>What does the <code class="language-plaintext highlighter-rouge">--bar</code> option do in <code class="language-plaintext highlighter-rouge">ack</code>?</li>
</ol>


<hr>

<div class="small center">
<p><a href="https://github.com/missing-semester/missing-semester/blob/master/_2019/command-line.md">Edit this page</a>.</p>
<p>Licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0">CC BY-NC-SA</a>.</p>
</div>

    </div>

  </body>

</html>
