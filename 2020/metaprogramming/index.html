<!DOCTYPE html>
<html lang="en">

  <head>
  <meta charset="utf-8" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png" />
  <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png" />
  <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png" />

  <meta name="twitter:card" content="summary_large_image" />
  <meta name="og:url" content="https://missing-semesters-ruet.github.io//2020/metaprogramming/" />
  <meta property="og:site_name" content="The Missing Semesters of Your CS" />

   
  <meta name="twitter:title" content="Metaprogramming" />
  <meta property="og:title" content="Metaprogramming" />

  

  <title>
      Metaprogramming &middot; The Missing Semesters of Your CS  
  </title>

  <link rel="stylesheet" href="/missing-semester/static/css/main.css" />
  <link rel="stylesheet" href="/missing-semester/static/css/syntax.css" />
  <link rel="stylesheet" href="/missing-semester/static/css/note.css" />
  <link
    href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:200,300,400,600,700,900,200italic,300italic,400italic,600italic,700italic,900italic&subset=latin,latin-ext"
    rel="stylesheet"
    type="text/css"
  />
  <link
    href="https://fonts.googleapis.com/css?family=Source+Code+Pro:200,300,400,500,600,700,900&subset=latin,latin-ext"
    rel="stylesheet"
    type="text/css"
  />

  <script
    async
    src="https://www.googletagmanager.com/gtag/js?id=G-P7WVHD84D1"
  ></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag() {
      dataLayer.push(arguments);
    }
    gtag("js", new Date());

    gtag("config", "G-P7WVHD84D1");
  </script>
</head>


  <body>

    <div id="nav-bg">
  <nav id="top-nav">
    <a href="/missing-semester/" id="logo">./missing-semester</a>
    <input type="checkbox" id="menu-icon" />
    <label class="menu-label" for="menu-icon"></label>
    <div class="trigger">
      <div class="trigger-child">
        <span class="nav-link"
          ><a href="/missing-semester/2025/">lectures</a></span
        >
        <span class="nav-link">
          <a href="/missing-semester/statement_of_intent"
            >statement of intent</a
          >
        </span>
        <span class="nav-link"
          ><a href="/missing-semester/about/">about</a></span
        >
      </div>
    </div>
  </nav>
</div>


    <div id="content">
    <h1 class="title">Metaprogramming</h1>


  <div class="youtube-wrapper" style="padding-bottom: 56.25%;">
    <iframe src="https://www.youtube.com/embed/_Ms1Z4xfqv4" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
  </div>


<p>What do we mean by “metaprogramming”? Well, it was the best collective
term we could come up with for the set of things that are more about
<em>process</em> than they are about writing code or working more efficiently.
In this lecture, we will look at systems for building and testing your
code, and for managing dependencies. These may seem like they are of
limited importance in your day-to-day as a student, but the moment you
interact with a larger code base through an internship or once you enter
the “real world”, you will see this everywhere. We should note that
“metaprogramming” can also mean “<a href="https://en.wikipedia.org/wiki/Metaprogramming">programs that operate on
programs</a>”, whereas that
is not quite the definition we are using for the purposes of this
lecture.</p>

<h1 id="build-systems">Build systems</h1>

<p>If you write a paper in LaTeX, what are the commands you need to run to
produce your paper? What about the ones used to run your benchmarks,
plot them, and then insert that plot into your paper? Or to compile the
code provided in the class you’re taking and then running the tests?</p>

<p>For most projects, whether they contain code or not, there is a “build
process”. Some sequence of operations you need to do to go from your
inputs to your outputs. Often, that process might have many steps, and
many branches. Run this to generate this plot, that to generate those
results, and something else to produce the final paper. As with so many
of the things we have seen in this class, you are not the first to
encounter this annoyance, and luckily there exist many tools to help
you!</p>

<p>These are usually called “build systems”, and there are <em>many</em> of them.
Which one you use depends on the task at hand, your language of
preference, and the size of the project. At their core, they are all
very similar though. You define a number of <em>dependencies</em>, a number of
<em>targets</em>, and <em>rules</em> for going from one to the other. You tell the
build system that you want a particular target, and its job is to find
all the transitive dependencies of that target, and then apply the rules
to produce intermediate targets all the way until the final target has
been produced. Ideally, the build system does this without unnecessarily
executing rules for targets whose dependencies haven’t changed and where
the result is available from a previous build.</p>

<p><code class="language-plaintext highlighter-rouge">make</code> is one of the most common build systems out there, and you will
usually find it installed on pretty much any UNIX-based computer. It has
its warts, but works quite well for simple-to-moderate projects. When
you run <code class="language-plaintext highlighter-rouge">make</code>, it consults a file called <code class="language-plaintext highlighter-rouge">Makefile</code> in the current
directory. All the targets, their dependencies, and the rules are
defined in that file. Let’s take a look at one:</p>

<div class="language-make highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nl">paper.pdf</span><span class="o">:</span> <span class="nf">paper.tex plot-data.png</span>
	pdflatex paper.tex

<span class="nl">plot-%.png</span><span class="o">:</span> <span class="nf">%.dat plot.py</span>
	./plot.py <span class="nt">-i</span> <span class="nv">$*</span>.dat <span class="nt">-o</span> <span class="nv">$@</span>
</code></pre></div></div>

<p>Each directive in this file is a rule for how to produce the left-hand
side using the right-hand side. Or, phrased differently, the things
named on the right-hand side are dependencies, and the left-hand side is
the target. The indented block is a sequence of programs to produce the
target from those dependencies. In <code class="language-plaintext highlighter-rouge">make</code>, the first directive also
defines the default goal. If you run <code class="language-plaintext highlighter-rouge">make</code> with no arguments, this is
the target it will build. Alternatively, you can run something like
<code class="language-plaintext highlighter-rouge">make plot-data.png</code>, and it will build that target instead.</p>

<p>The <code class="language-plaintext highlighter-rouge">%</code> in a rule is a “pattern”, and will match the same string on the
left and on the right. For example, if the target <code class="language-plaintext highlighter-rouge">plot-foo.png</code> is
requested, <code class="language-plaintext highlighter-rouge">make</code> will look for the dependencies <code class="language-plaintext highlighter-rouge">foo.dat</code> and
<code class="language-plaintext highlighter-rouge">plot.py</code>. Now let’s look at what happens if we run <code class="language-plaintext highlighter-rouge">make</code> with an empty
source directory.</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span>make
<span class="go">make: *** No rule to make target 'paper.tex', needed by 'paper.pdf'.  Stop.
</span></code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">make</code> is helpfully telling us that in order to build <code class="language-plaintext highlighter-rouge">paper.pdf</code>, it
needs <code class="language-plaintext highlighter-rouge">paper.tex</code>, and it has no rule telling it how to make that file.
Let’s try making it!</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span><span class="nb">touch </span>paper.tex
<span class="gp">$</span><span class="w"> </span>make
<span class="go">make: *** No rule to make target 'plot-data.png', needed by 'paper.pdf'.  Stop.
</span></code></pre></div></div>

<p>Hmm, interesting, there <em>is</em> a rule to make <code class="language-plaintext highlighter-rouge">plot-data.png</code>, but it is a
pattern rule. Since the source files do not exist (<code class="language-plaintext highlighter-rouge">data.dat</code>), <code class="language-plaintext highlighter-rouge">make</code>
simply states that it cannot make that file. Let’s try creating all the
files:</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span><span class="nb">cat </span>paper.tex
<span class="go">\documentclass{article}
\usepackage{graphicx}
\begin{document}
\includegraphics[scale=0.65]{plot-data.png}
\end{document}
</span><span class="gp">$</span><span class="w"> </span><span class="nb">cat </span>plot.py
<span class="gp">#</span><span class="o">!</span>/usr/bin/env python
<span class="go">import matplotlib
import matplotlib.pyplot as plt
import numpy as np
import argparse

parser = argparse.ArgumentParser()
parser.add_argument('-i', type=argparse.FileType('r'))
parser.add_argument('-o')
args = parser.parse_args()

data = np.loadtxt(args.i)
plt.plot(data[:, 0], data[:, 1])
plt.savefig(args.o)
</span><span class="gp">$</span><span class="w"> </span><span class="nb">cat </span>data.dat
<span class="go">1 1
2 2
3 3
4 4
5 8
</span></code></pre></div></div>

<p>Now what happens if we run <code class="language-plaintext highlighter-rouge">make</code>?</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span>make
<span class="go">./plot.py -i data.dat -o plot-data.png
pdflatex paper.tex
... lots of output ...
</span></code></pre></div></div>

<p>And look, it made a PDF for us!
What if we run <code class="language-plaintext highlighter-rouge">make</code> again?</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span>make
<span class="go">make: 'paper.pdf' is up to date.
</span></code></pre></div></div>

<p>It didn’t do anything! Why not? Well, because it didn’t need to. It
checked that all of the previously-built targets were still up to date
with respect to their listed dependencies. We can test this by modifying
<code class="language-plaintext highlighter-rouge">paper.tex</code> and then re-running <code class="language-plaintext highlighter-rouge">make</code>:</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span><span class="w"> </span>vim paper.tex
<span class="gp">$</span><span class="w"> </span>make
<span class="go">pdflatex paper.tex
</span><span class="c">...
</span></code></pre></div></div>

<p>Notice that <code class="language-plaintext highlighter-rouge">make</code> did <em>not</em> re-run <code class="language-plaintext highlighter-rouge">plot.py</code> because that was not
necessary; none of <code class="language-plaintext highlighter-rouge">plot-data.png</code>’s dependencies changed!</p>

<h1 id="dependency-management">Dependency management</h1>

<p>At a more macro level, your software projects are likely to have
dependencies that are themselves projects. You might depend on installed
programs (like <code class="language-plaintext highlighter-rouge">python</code>), system packages (like <code class="language-plaintext highlighter-rouge">openssl</code>), or libraries
within your programming language (like <code class="language-plaintext highlighter-rouge">matplotlib</code>). These days, most
dependencies will be available through a <em>repository</em> that hosts a
large number of such dependencies in a single place, and provides a
convenient mechanism for installing them. Some examples include the
Ubuntu package repositories for Ubuntu system packages, which you access
through the <code class="language-plaintext highlighter-rouge">apt</code> tool, RubyGems for Ruby libraries, PyPI for Python
libraries, or the Arch User Repository for Arch Linux user-contributed
packages.</p>

<p>Since the exact mechanisms for interacting with these repositories vary
a lot from repository to repository and from tool to tool, we won’t go
too much into the details of any specific one in this lecture. What we
<em>will</em> cover is some of the common terminology they all use. The first
among these is <em>versioning</em>. Most projects that other projects depend on
issue a <em>version number</em> with every release. Usually something like
8.1.3 or 64.1.20192004. They are often, but not always, numerical.
Version numbers serve many purposes, and one of the most important of
them is to ensure that software keeps working. Imagine, for example,
that I release a new version of my library where I have renamed a
particular function. If someone tried to build some software that
depends on my library after I release that update, the build might fail
because it calls a function that no longer exists! Versioning attempts
to solve this problem by letting a project say that it depends on a
particular version, or range of versions, of some other project. That
way, even if the underlying library changes, dependent software
continues building by using an older version of my library.</p>

<p>That also isn’t ideal though! What if I issue a security update which
does <em>not</em> change the public interface of my library (its “API”), and
which any project that depended on the old version should immediately
start using? This is where the different groups of numbers in a version
come in. The exact meaning of each one varies between projects, but one
relatively common standard is <a href="https://semver.org/"><em>semantic
versioning</em></a>. With semantic versioning, every
version number is of the form: major.minor.patch. The rules are:</p>

<ul>
  <li>If a new release does not change the API, increase the patch version.</li>
  <li>If you <em>add</em> to your API in a backwards-compatible way, increase the
minor version.</li>
  <li>If you change the API in a non-backwards-compatible way, increase the
major version.</li>
</ul>

<p>This already provides some major advantages. Now, if my project depends
on your project, it <em>should</em> be safe to use the latest release with the
same major version as the one I built against when I developed it, as
long as its minor version is at least what it was back then. In other
words, if I depend on your library at version <code class="language-plaintext highlighter-rouge">1.3.7</code>, then it <em>should</em>
be fine to build it with <code class="language-plaintext highlighter-rouge">1.3.8</code>, <code class="language-plaintext highlighter-rouge">1.6.1</code>, or even <code class="language-plaintext highlighter-rouge">1.3.0</code>. Version
<code class="language-plaintext highlighter-rouge">2.2.4</code> would probably not be okay, because the major version was
increased. We can see an example of semantic versioning in Python’s
version numbers. Many of you are probably aware that Python 2 and Python
3 code do not mix very well, which is why that was a <em>major</em> version
bump. Similarly, code written for Python 3.5 might run fine on Python
3.7, but possibly not on 3.4.</p>

<p>When working with dependency management systems, you may also come
across the notion of <em>lock files</em>. A lock file is simply a file that
lists the exact version you are <em>currently</em> depending on of each
dependency. Usually, you need to explicitly run an update program to
upgrade to newer versions of your dependencies. There are many reasons
for this, such as avoiding unnecessary recompiles, having reproducible
builds, or not automatically updating to the latest version (which may
be broken). An extreme version of this kind of dependency locking is
<em>vendoring</em>, which is where you copy all the code of your dependencies
into your own project. That gives you total control over any changes to
it, and lets you introduce your own changes to it, but also means you
have to explicitly pull in any updates from the upstream maintainers
over time.</p>

<h1 id="continuous-integration-systems">Continuous integration systems</h1>

<p>As you work on larger and larger projects, you’ll find that there are
often additional tasks you have to do whenever you make a change to it.
You might have to upload a new version of the documentation, upload a
compiled version somewhere, release the code to pypi, run your test
suite, and all sort of other things. Maybe every time someone sends you
a pull request on GitHub, you want their code to be style checked and
you want some benchmarks to run? When these kinds of needs arise, it’s
time to take a look at continuous integration.</p>

<p>Continuous integration, or CI, is an umbrella term for “stuff that runs
whenever your code changes”, and there are many companies out there that
provide various types of CI, often for free for open-source projects.
Some of the big ones are Travis CI, Azure Pipelines, and GitHub Actions.
They all work in roughly the same way: you add a file to your repository
that describes what should happen when various things happen to that
repository. By far the most common one is a rule like “when someone
pushes code, run the test suite”. When the event triggers, the CI
provider spins up a virtual machines (or more), runs the commands in
your “recipe”, and then usually notes down the results somewhere. You
might set it up so that you are notified if the test suite stops
passing, or so that a little badge appears on your repository as long as
the tests pass.</p>

<p>As an example of a CI system, the class website is set up using GitHub
Pages. Pages is a CI action that runs the Jekyll blog software on every
push to <code class="language-plaintext highlighter-rouge">master</code> and makes the built site available on a particular
GitHub domain. This makes it trivial for us to update the website! We
just make our changes locally, commit them with git, and then push. CI
takes care of the rest.</p>

<h2 id="a-brief-aside-on-testing">A brief aside on testing</h2>

<p>Most large software projects come with a “test suite”. You may already
be familiar with the general concept of testing, but we thought we’d
quickly mention some approaches to testing and testing terminology that
you may encounter in the wild:</p>

<ul>
  <li>Test suite: a collective term for all the tests</li>
  <li>Unit test: a “micro-test” that tests a specific feature in isolation</li>
  <li>Integration test: a “macro-test” that runs a larger part of the
system to check that different feature or components work <em>together</em>.</li>
  <li>Regression test: a test that implements a particular pattern that
<em>previously</em> caused a bug to ensure that the bug does not resurface.</li>
  <li>Mocking: to replace a function, module, or type with a fake
implementation to avoid testing unrelated functionality. For example,
you might “mock the network” or “mock the disk”.</li>
</ul>

<h1 id="exercises">Exercises</h1>

<ol>
  <li>Most makefiles provide a target called <code class="language-plaintext highlighter-rouge">clean</code>. This isn’t intended
to produce a file called <code class="language-plaintext highlighter-rouge">clean</code>, but instead to clean up any files
that can be re-built by make. Think of it as a way to “undo” all of
the build steps. Implement a <code class="language-plaintext highlighter-rouge">clean</code> target for the <code class="language-plaintext highlighter-rouge">paper.pdf</code>
<code class="language-plaintext highlighter-rouge">Makefile</code> above. You will have to make the target
<a href="https://www.gnu.org/software/make/manual/html_node/Phony-Targets.html">phony</a>.
You may find the <a href="https://git-scm.com/docs/git-ls-files"><code class="language-plaintext highlighter-rouge">git
ls-files</code></a> subcommand useful.
A number of other very common make targets are listed
<a href="https://www.gnu.org/software/make/manual/html_node/Standard-Targets.html#Standard-Targets">here</a>.</li>
  <li>Take a look at the various ways to specify version requirements for
dependencies in <a href="https://doc.rust-lang.org/cargo/reference/specifying-dependencies.html">Rust’s build
system</a>.
Most package repositories support similar syntax. For each one
(caret, tilde, wildcard, comparison, and multiple), try to come up
with a use-case in which that particular kind of requirement makes
sense.</li>
  <li>Git can act as a simple CI system all by itself. In <code class="language-plaintext highlighter-rouge">.git/hooks</code>
inside any git repository, you will find (currently inactive) files
that are run as scripts when a particular action happens. Write a
<a href="https://git-scm.com/docs/githooks#_pre_commit"><code class="language-plaintext highlighter-rouge">pre-commit</code></a> hook
that runs <code class="language-plaintext highlighter-rouge">make paper.pdf</code> and refuses the commit if the <code class="language-plaintext highlighter-rouge">make</code>
command fails. This should prevent any commit from having an
unbuildable version of the paper.</li>
  <li>Set up a simple auto-published page using <a href="https://pages.github.com/">GitHub
Pages</a>.
Add a <a href="https://github.com/features/actions">GitHub Action</a> to the
repository to run <code class="language-plaintext highlighter-rouge">shellcheck</code> on any shell files in that
repository (here is <a href="https://github.com/marketplace/actions/shellcheck">one way to do
it</a>). Check that
it works!</li>
  <li><a href="https://help.github.com/en/actions/automating-your-workflow-with-github-actions/building-actions">Build your
own</a>
GitHub action to run <a href="https://github.com/amperser/proselint"><code class="language-plaintext highlighter-rouge">proselint</code></a> or
<a href="https://github.com/btford/write-good"><code class="language-plaintext highlighter-rouge">write-good</code></a> on all the
<code class="language-plaintext highlighter-rouge">.md</code> files in the repository. Enable it in your repository, and
check that it works by filing a pull request with a typo in it.</li>
</ol>


<hr>

<div class="small center">
<p><a href="https://github.com/missing-semester/missing-semester/blob/master/_2020/metaprogramming.md">Edit this page</a>.</p>
<p>Licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0">CC BY-NC-SA</a>.</p>
</div>

    </div>

  </body>

</html>
